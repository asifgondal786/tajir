import React, { useState, useEffect, useRef } from "react";
import { Box, Text, Newline, measureElement } from "ink";
import chalk from "chalk";
import { fetchImage, calculateImageSize } from "../../utils/image.js";
import { useTerminalCapabilities } from "../../context/TerminalInfo.js";
/**
 * Half-Block Image Rendering Component
 *
 * Renders images using Unicode half-block characters (▄) with colored backgrounds and foregrounds.
 * This method provides higher resolution than ASCII art by utilizing both the character color
 * and background color to represent two pixels per character cell.
 *
 * Features:
 * - Higher resolution than ASCII (2 pixels per character)
 * - Full color support using terminal RGB colors
 * - Requires Unicode and color support
 * - Good balance between quality and compatibility
 *
 * Technical Details:
 * - Uses Unicode half-block character (U+2584 ▄)
 * - Top pixel represented by background color
 * - Bottom pixel represented by foreground color
 * - Requires terminal color and Unicode support
 * - Processes images in pairs of vertical pixels
 *
 * @param props - Image rendering properties
 * @returns JSX element containing half-block representation of the image
 */
function HalfBlockImage(props) {
    const [imageOutput, setImageOutput] = useState(null);
    const [hasError, setHasError] = useState(false);
    const containerRef = useRef(null);
    const terminalCapabilities = useTerminalCapabilities();
    const { onSupportDetected, src, width: propsWidth, height: propsHeight, } = props;
    // Detect support and notify parent
    useEffect(() => {
        if (!terminalCapabilities)
            return;
        const isSupported = terminalCapabilities.supportsColor &&
            terminalCapabilities.supportsUnicode;
        onSupportDetected?.(isSupported);
    }, [onSupportDetected, terminalCapabilities]);
    useEffect(() => {
        const generateImageOutput = async () => {
            const image = await fetchImage(src);
            if (!image) {
                setHasError(true);
                return;
            }
            setHasError(false);
            const metadata = await image.metadata();
            if (!containerRef.current)
                return;
            const { width: maxWidth, height: maxHeight } = measureElement(containerRef.current);
            const { width, height } = calculateImageSize({
                maxWidth: maxWidth,
                maxHeight: maxHeight * 2,
                originalAspectRatio: metadata.width / metadata.height,
                specifiedWidth: propsWidth,
                specifiedHeight: propsHeight ? propsHeight * 2 : undefined,
            });
            const resizedImage = await image
                .resize(width, height)
                .raw()
                .toBuffer({ resolveWithObject: true });
            const output = await toHalfBlocks(resizedImage);
            setImageOutput(output);
        };
        generateImageOutput();
    }, [src, propsWidth, propsHeight]);
    return (React.createElement(Box, { ref: containerRef, flexDirection: "column", flexGrow: 1 }, imageOutput ? (imageOutput
        .split("\n")
        .map((line, index) => React.createElement(Text, { key: index }, line))) : (React.createElement(Box, { flexDirection: "column", alignItems: "center", justifyContent: "center" },
        hasError && (React.createElement(Text, { color: "red" },
            "X",
            React.createElement(Newline, null),
            "Load failed")),
        React.createElement(Text, { color: "gray" }, props.alt || "Loading...")))));
}
/** Unicode half-block character (▄) used for rendering */
const HALF_BLOCK = "\u2584";
/**
 * Converts image data to half-block representation.
 *
 * This function processes the image by:
 * 1. Iterating through pixels in pairs (top and bottom)
 * 2. Using the top pixel color as background
 * 3. Using the bottom pixel color as foreground
 * 4. Rendering a half-block character with these colors
 * 5. Handling transparency by using spaces for transparent pixels
 *
 * The half-block character (▄) fills the bottom half of the character cell,
 * so the background color shows through the top half, effectively displaying
 * two pixels per character position.
 *
 * Adapted from https://github.com/sindresorhus/terminal-image
 *
 * @param imageData - Raw image data from Sharp with buffer and metadata
 * @returns Promise resolving to formatted string with colored half-block characters
 */
async function toHalfBlocks(imageData) {
    const { data, info } = imageData;
    const { width, height, channels } = info;
    let result = "";
    for (let y = 0; y < height - 1; y += 2) {
        for (let x = 0; x < width; x++) {
            const topPixelIndex = (y * width + x) * channels;
            const bottomPixelIndex = ((y + 1) * width + x) * channels;
            const r = data[topPixelIndex];
            const g = data[topPixelIndex + 1];
            const b = data[topPixelIndex + 2];
            const a = channels === 4 ? data[topPixelIndex + 3] : 255;
            const r2 = data[bottomPixelIndex];
            const g2 = data[bottomPixelIndex + 1];
            const b2 = data[bottomPixelIndex + 2];
            result +=
                a === 0
                    ? chalk.reset(" ")
                    : chalk.bgRgb(r, g, b).rgb(r2, g2, b2)(HALF_BLOCK);
        }
        result += "\n";
    }
    return result;
}
export default HalfBlockImage;
